#!/bin/sh
#
#  mactk - MAC toolkit: various commands for network social-engineering
#  Copyright (C) 2022 Zhang Maiyun <myzhang1029@hotmail.com>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <https://www.gnu.org/licenses/>.
#

# For full functionality, have these commands handy:
# avahi-resolve (linux only)
# ip or arp and ndp
# curl or wget
# arping, nbtscan, nmblookup, ping6
# tr, grep, sed, awk, sort, uniq

# We use REGEX instead of parsing the fields so that we get nothing if the
# link is incomplete, instead of some non-MAC nonsense.
MAC_REGEX='[a-fA-F0-9]\{1,2\}\(:[a-fA-F0-9]\{1,2\}\)\{5\}'
IP4_REGEX='\([0-9]\{1,3\}\.\)\{3\}[0-9]\{1,3\}'
PING_TO_IP_SED='s/.*[(]\([0-9a-fA-F.:]*\)[)].*/\1/'

# Pad MAC addresses with 0 if they are omitted
_pad_mac()
{
    sed 's/^\([0-9A-Fa-f]\):/0\1:/;
    s/:\([0-9A-Fa-f]\)$/:0\1/;
    s/\([^0-9A-Fa-f]\)\([0-9A-Fa-f]\):/\10\2:/g;
    s/\([^0-9A-Fa-f]\)\([0-9A-Fa-f]\):/\10\2:/g'
}

# Check whether a command is present
_has()
{
    command -v "$1" > /dev/null 2>&1
}

# Check if $1 is not a hostname
# We are currently not trying to match IPv6 addresses with regex but
# instead we check if a colon is present
_is_ipv6()
{
    [ -z "${1##*:*}" ]
}

_is_ipv4()
{
    printf "%s\n" "$1" | grep "${IP4_REGEX}" > /dev/null 2>&1
}

_is_ip()
{
    _is_ipv6 "$1" || _is_ipv4 "$1"
}

# Resolve hostname to IP (either v4 or v6)
_resolve_hostname()
{
    if [ -z "$1" ]
    then
        return
    fi
    # The default resolver can deal with a lot of the cases and is fast
    if _has dig
    then
        result="$(dig +short "$1")" || result=""
    fi
    # nbtscan -> NetBIOS names have no dots and is always UPPER CASE
    if [ -z "${result}" ] && [ -n "${1##*"."*}" ] && [ -n "${1##*[a-z]*}" ]
    then
        if _has nmblookup
        then
            # nmblookup output errors to stdout. fix that
            result="$(nmblookup "$1")" || result=""
            result="$(printf "%s\n" "${result}" | awk '{print $1}')"
        fi
        if [ -z "${result}" ] && _has dig
        then
            # macOS does not respond to this
            # dig also output errors to stdout. fix that
            result="$(dig +short +noedns -p 5355 @224.0.0.252 "$1")" || result=""
        fi
    elif [ -z "${1##*".local"}" ]
    then
        if _has avahi-resolve
        then
            result="$(avahi-resolve -n "$1" | awk '{print $2}')" || result=""
        fi
        if [ -z "${result}" ] && _has dig
        then
            result="$(dig +short -p 5353 @224.0.0.251 "$1")" || result=""
        fi
    fi
    if [ -n "${result}" ]
    then
        # Deal with potential multiple answers
        printf "%s\n" "${result}" | head -n1
    else
        ping -nqc1 "$1" | head -n1 | sed "${PING_TO_IP_SED}"
    fi
}

# Get MAC vendor
get_mac_vendor()
{
    if _has curl
    then
        curl -sL http://api.macvendors.com/"$1"
    elif _has wget
    then
        wget -qO- http://api.macvendors.com/"$1"
    fi
    ret=$?
    # Conform to rate limit
    sleep 0.5 2> /dev/null || true
    return "${ret}"
}

# Get MAC address from IP or hostname
get_mac()
{
    # Try to discover the link for IPv6, arping takes care of this case for IPv4
    if _is_ipv6 "$1" && _has ping6
    then
        ping6 -nqc1 "$1" > /dev/null 2>&1 || true
    fi

    # We do no try to guess the ip family or interface

    # Prefer `ip` regardless
    if _has ip
    then
        # `ip` command does not support hostnames
        if ! _is_ip "$1"
        then
            target="$(_resolve_hostname "$1")"
        else
            target="$1"
        fi
        # This command returns matches on any interfaces
        result="$(ip neigh show "${target}" | \
            grep -io "${MAC_REGEX}" | \
            # So we dedupe
            sort | uniq | \
            # And convert newlines to spaces
            tr '\n' ' ' | \
            # And remove the final space
            xargs
        )"
    else
        # Fallback to those IP-family-dependent tools
        if _has arp
        then
            result="$(arp -n "$1" | grep -io "${MAC_REGEX}" | _pad_mac)"
        fi
        # Use the non-empty one if there is one
        # Theoretically there should only be one that is non-empty
        if [ -z "${result}" ] && _has ndp
        then
            result="$(ndp -n "$1" | grep -io "${MAC_REGEX}" | _pad_mac)"
        fi
    fi

    # arping is slower, don't use unless necessary (i.e. we have to discover that device)
    # arping does not work for IPv6, but ndisc6 would require us to specify an interface
    if [ -z "${result}" ] && _has arping && ! _is_ipv6 "$1"
    then
        result="$(arping -C1 -c3 "$1" | grep -io "${MAC_REGEX}" | tail -n1)"
    fi

    printf "%s\n" "${result}"
    [ -n "${result}" ]
}

# Get IPv4 address from MAC
get_ipv4()
{
    if _has ip
    then
        result="$(ip neigh | grep "\<$1\>" | grep -io "${IP4_REGEX}")"
    fi
    if [ -z "${result}" ] && _has arp
    then
        result="$(arp -an | grep "\<$1\>" | grep -io "${IP4_REGEX}")"
    fi
    # arping is slower, don't use unless necessary
    if [ -z "${result}" ] && _has arping
    then
        result="$(arping -c3 "$1" | grep -io "${IP4_REGEX}" | tail -n1)"
    fi

    printf "%s\n" "${result}"
    [ -n "${result}" ]
}

# Resolve MAC and verify the hostname $2 is still IP $1
_get_mac2()
{
    # Get MAC from the IP
    mac1="$(get_mac "$1")"
    
    # Double check if that hostname still point to the same IP
    ip2="$(_resolve_hostname "$2")"
    if [ "${ip2}" = "${ip}" ] || [ -z "${ip2}" ]
    then
        printf "%s\n" "${mac1}"
        return 0
    else
        mac2="$(get_mac "${ip2}")"
        if [ "${mac1}" = "${mac2}" ] || [ -z "${mac2}" ]
        then
            printf "%s\n" "${mac1}"
            return 0
        elif [ -z "${mac1}" ]
        then
            printf "%s\n" "${mac2}"
            return 0
        else
            # Problem: the host has changed its IP or hostname
            printf "%s\t%s\n" "${mac1}" "${mac2}"
            return 2
        fi
    fi
}

# Takes an input of format (avahi-resolve -a) $IP <SPACE> $HOSTNAME
# and add a third or fourth column of the MAC addresses
resolve_all()
{
    # Read the input line by line
    while IFS= read -r line
    do
        ip="$(printf "%s" "${line}" | awk '{print $1}')"
        hn="$(printf "%s" "${line}" | awk '{print $2}')"
        printf "%s\t%s\t" "${ip}" "${hn}"
        _get_mac2 "${ip}" "${hn}"
    done
}

# Scan IP addresses for mDNS or NetBIOS hosts
# Do not use CIDR, use individual addresses
# avahi-resolve supports IPv6, but nbtscan doesn't
scan_ips()
{
    # TODO: Implement discovery with dns-sd?
    if _has avahi-resolve
    then
        avahi_out="$(avahi-resolve -a "$@" | resolve_all)"
        in_avahi="$(printf "%s\n" "${avahi_out}" | \
            awk '{print "|" $1 "-" $3 ";"}')"
        printf "%s\n" "${avahi_out}"
    fi

    if _has nbtscan
    then
        tmp_file="$(mktemp)"
        printf "%s\n" "$@" | tr ' ' '\n' > "${tmp_file}"
        nbtscan -qf "${tmp_file}" | \
            while IFS= read -r ln
            do
                ip="$(printf "%s\n" "${ln}" | awk '{print $1}')"
                # Don't add .local at this step to ease resolution.
                # macOS also does not respond to NetBIOS name queries over mDNS
                hn="$(printf "%s\n" "${ln}" | awk '{print $2}')"
                mac="$(printf "%s\n" "${ln}" | awk '{print $5}')"

                if [ -z "${mac}" ]
                then
                    mac="$(_get_mac2 "${ip}" "${hn}")"
                fi

                # Prefer mDNS hostnames over NBNS names
                # because e.g. Macs have both, but the mDNS one is juicier
                if [ -z "${in_avahi}" ] || [ -n "${in_avahi##*"|${ip}-${mac};"*}" ]
                then
                    printf "%s\t%s.local\t%s\n" "${ip}" "${hn}" "${mac}"
                fi
            done
        rm "${tmp_file}"
    fi
}

# Run `$1 {}` which {} is each of "$@"
_foreach()
{
    COMMAND="$1"
    shift
    while [ "$#" -ge 1 ]
    do
        "${COMMAND}" "$1"
        shift
    done
}

COMMAND="$1"
shift || true

case "${COMMAND}" in
    s|scan)
        scan_ips "$@"
        ;;
    m|mac)
        _foreach get_mac "$@"
        ;;
    4|ip4|ipv4)
        _foreach get_ipv4 "$@"
        ;;
    v|vendor)
        _foreach get_mac_vendor "$@"
        ;;
    r|resolve)
        # `cat` handles '-' for us
        cat "$@" | resolve_all
        ;;
    *)
        echo "Unknown command ${COMMAND}" >&2
        exit 1
esac
