#!/bin/sh
#
#  mactk - MAC toolkit: various commands for network social-engineering
#  Copyright (C) 2022 Zhang Maiyun <myzhang1029@hotmail.com>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <https://www.gnu.org/licenses/>.
#

# For full functionality, have these commands handy:
# avahi-resolve (linux only)
# ip or arp and ndp
# curl or wget
# arping, nbtscan, ping6
# tr, grep, sed, awk, sort, uniq

# We use REGEX instead of parsing the fields so that we get nothing if the
# link is incomplete, instead of some non-MAC nonsense.
MAC_REGEX='[a-fA-F0-9]\{1,2\}\(:[a-fA-F0-9]\{1,2\}\)\{5\}'
IP4_REGEX='\([0-9]\{1,3\}\.\)\{3\}[0-9]\{1,3\}'

# Pad MAC addresses with 0 if they are omitted
_pad_mac()
{
    sed 's/^\([0-9A-Fa-f]\):/0\1:/;
    s/:\([0-9A-Fa-f]\)$/:0\1/;
    s/\([^0-9A-Fa-f]\)\([0-9A-Fa-f]\):/\10\2:/g;
    s/\([^0-9A-Fa-f]\)\([0-9A-Fa-f]\):/\10\2:/g'
}

# Check whether a command is present
_has()
{
    which "$1" > /dev/null 2>&1
}

# Check if $1 is not a hostname
# We are currently not trying to match IPv6 addresses with regex but
# instead we check if a colon is present
_is_ipv6()
{
    [ -z "${1##*:*}" ]
}

_is_ipv4()
{
    printf "%s\n" "$1" | grep "$IP4_REGEX" > /dev/null 2>&1
}

_is_ip()
{
    _is_ipv6 "$1" || _is_ipv4 "$1"
}

# Resolve hostname to IP (either v4 or v6)
_resolve_hostname()
{
    if [ -z "$1" ]
    then
        return
    elif [ -z "${1##*".local"}" ] && _has avahi-resolve
    then
        avahi-resolve -n "$1" | awk '{print $2}'
    elif [ -z "${1##*".local"}" ] && _has dig
    then
        dig +short -p 5353 @224.0.0.251 "$1"
    elif _has dig
    then
        dig +short "$1"
    else
        ping -nqc1 "$1" | head -n1 | sed 's/.*[(]\([0-9a-fA-F.]*\)[)].*/\1/'
    fi
}

# Get MAC vendor
get_mac_vendor()
{
    if _has curl
    then
        # `printf` is used to ensure a correct LF
        printf "%s\n" "$(curl -sL http://api.macvendors.com/"$1")"
    elif _has wget
    then
        printf "%s\n" "$(wget -qO- http://api.macvendors.com/"$1")"
    fi
    # Conform to rate limit
    sleep 0.5 2> /dev/null || true
}

# Get MAC address from IP or hostname
get_mac()
{
    # Try to discover the link for IPv6, arping takes care of this case for IPv4
    if _is_ipv6 "$1" && _has ping6
    then
        ping6 -nqc1 "$1" > /dev/null 2>&1
    fi

    # We do no try to guess the ip family or interface

    if _has ip
    then
        # Prefer `ip` regardless
        # `ip` command does not support hostnames
        if ! _is_ip "$1"
        then
            target="$(_resolve_hostname "$1")"
        else
            target="$1"
        fi
        # This command returns matches on any interfaces
        result="$(ip neigh show "$target" | \
            grep -io "$MAC_REGEX" | \
            # So we dedupe
            sort | uniq | \
            # And convert newlines to spaces
            tr '\n' ' ' | \
            # And remove the final space
            xargs
        )"
    else
        # Fallback to those IP-family-dependent tools
        if _has arp
        then
            result="$(arp -n "$1" | grep -io "$MAC_REGEX" | _pad_mac)"
        fi
        # Use the non-empty one if there is one
        # Theoretically there should only be one that is non-empty
        if [ -z "$result" ] && _has ndp
        then
            result="$(ndp -n "$1" | grep -io "$MAC_REGEX" | _pad_mac)"
        fi
    fi

    # arping is slower, don't use unless necessary (i.e. we have to discover that device)
    # arping does not work for IPv6, but ndisc6 would require us to specify an interface
    if [ -z "$result" ] && _has arping && ! _is_ipv6 "$1"
    then
        result="$(arping -c3 "$1" | grep -io "$MAC_REGEX" | tail -n1)"
    fi

    printf "%s\n" "$result"
}

# Get IPv4 address from MAC
get_ipv4()
{
    if _has ip
    then
        result="$(ip neigh | grep "\<$1\>" | grep -io "$IP4_REGEX")"
    fi
    if [ -z "$result" ] && _has arp
    then
        result="$(arp -an | grep "\<$1\>" | grep -io "$IP4_REGEX")"
    fi
    # arping is slower, don't use unless necessary
    if [ -z "$result" ] && _has arping
    then
        result="$(arping -c3 "$1" | grep -io "$IP4_REGEX" | tail -n1)"
    fi

    printf "%s\n" "$result"
}

# Resolve MAC and verify the hostname $2 is still IP $1
_get_mac2()
{
    # Get MAC from the IP
    mac1="$(get_mac "$1")"
    
    # Double check if that hostname still point to the same IP
    ip2="$(_resolve_hostname "$2")"
    if [ "$ip2" = "$ip" ]
    then
        printf "%s\n" "$mac1"
    else
        mac2="$(get_mac "$ip2")"
        if [ "$mac1" = "$mac2" ] || [ -z "$mac2" ]
        then
            printf "%s\n" "$mac1"
        elif [ -z "$mac1" ]
        then
            printf "%s\n" "$mac2"
        else
            # Problem: the host has changed its IP or hostname
            printf "%s\t%s\n" "$mac1" "$mac2"
        fi
    fi
}

# Takes an input of format (avahi-resolve -a) $IP <SPACE> $HOSTNAME
# and add a third or fourth column of the MAC addresses
resolve_all()
{
    # Read the input line by line
    while IFS= read -r line
    do
        ip="$(printf "%s" "$line" | awk '{print $1}')"
        hn="$(printf "%s" "$line" | awk '{print $2}')"
        printf "%s\t%s\t" "$ip" "$hn"
        _get_mac2 "$ip" "$hn"
    done
}

# Scan IP addresses for mDNS or NetBIOS hosts
# Do not use CIDR, use individual addresses
# avahi-resolve supports IPv6, but nbtscan doesn't
scan_ips()
{
    # TODO: Implement discovery with dns-sd?
    if _has avahi-resolve
    then
        avahi_out="$(avahi-resolve -a "$@" | resolve_all)"
        in_avahi="$(printf "%s\n" "$avahi_out" | \
            awk '{print "|" $1 "-" $3 ";"}')"
        printf "%s\n" "$avahi_out"
    fi

    if _has nbtscan
    then
        tmp_file="$(mktemp)"
        printf "%s\n" "$@" | tr ' ' '\n' > "$tmp_file"
        nbtscan -qf "$tmp_file" | \
            while IFS= read -r ln
            do
                ip="$(printf "%s\n" "$ln" | awk '{print $1}')"
                hn="$(printf "%s\n" "$ln" | awk '{print $2}').local"
                mac="$(printf "%s\n" "$ln" | awk '{print $5}')"

                if [ -z "$mac" ]
                then
                    mac="$(_get_mac2 "$ip" "$hn")"
                fi

                # Prefer mDNS hostnames over NBNS names
                # because e.g. Macs have both, but the mDNS one is juicier
                if [ -n "${in_avahi##*"|$ip-$mac;"*}" ]
                then
                    printf "%s\t%s\t%s\n" "$ip" "$hn" "$mac"
                fi
            done
        rm "$tmp_file"
    fi
}

# Run `$1 {}` which {} is each of "$@"
_foreach()
{
    COMMAND="$1"
    shift
    while [ "$#" -ge 1 ]
    do
        "$COMMAND" "$1"
        shift
    done
}

COMMAND="$1"
shift || true

case "$COMMAND" in
    s|scan)
        scan_ips "$@"
        ;;
    m|mac)
        _foreach get_mac "$@"
        ;;
    4|ip4|ipv4)
        _foreach get_ipv4 "$@"
        ;;
    v|vendor)
        _foreach get_mac_vendor "$@"
        ;;
    r|resolve)
        # `cat` handles '-' for us
        cat "$@" | resolve_all
        ;;
esac
